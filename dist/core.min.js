export class Track{constructor(t){if(!t.src||!t.title)throw new Error("Invalid Constructor! Title and src are required!");this.filetype=t.filetype,this.src=t.src,this.title=t.title}toJSON(){let t={};return t.filetype=this.filetype,t.src=this.src,t.title=this.title,t}clone(){return this.constructor.fromJSON(JSON.stringify(this))}equals(t){return JSON.stringify(this)===JSON.stringify(t)}compare(t,r="title"){return this[r]<t[r]?-1:this[r]>t[r]?1:this[r]===t[r]?0:void 0===this[r]?-1:void 0===t[r]?1:0}toString(){return JSON.stringify(this)}valueOf(){return JSON.stringify({src:this.src,title:this.title})}static fromJSON(t){return new Track(JSON.parse(t))}}
export class EventTarget{constructor(r=!0){this._subscribers={all:[]},this._ready=1==r}async destroy(){let r=await this.publish(new this.constructor.Event("destroy"));return this.ready=!1,Object.values(this._subscribers).forEach((function(r){r.length=0})),r}get ready(){return this._ready}set ready(r){this._ready=1==r,this._ready&&this.publish(new this.constructor.Event("ready"))}subscribe(r){if(!r.type)throw new Error("Subscriber must specify a type!");if(!r.callback)throw new Error("Subscriber must include a callback!");if("function"!=typeof r.callback)throw new Error("Callback must be a function");if("ready"===r.type&&this._ready)return r.callback(new this.constructor.Event("ready"));this._subscribers[r.type]||(this._subscribers[r.type]=[]),this._subscribers[r.type].push(r)}unsubscribe(r){if(!r.type)throw new Error("Subscriber must specify a type!");if(!r.callback)throw new Error("Subscriber must include a callback!");if("function"!=typeof r.callback)throw new Error("Callback must be a function");this._subscribers[r.type]&&(this._subscribers[r.type]=this._subscribers[r.type].filter((function(t){for(let e in t)if(t[e]!==r[e])return!0;return!1})))}async publish(r){if(this._ready||await this.waitForEvent("ready"),!r.type)throw new Error("Event must specify a type!");r.target=this;let t=Object.keys(this._subscribers).filter((function(t){return"error"===r.type||("all"===t||t===r.type)})),f=function(t){return"error"===r.type&&t.error&&"error"!==this?t.error(r):t.callback(r),!t.once};return t.forEach(function(r){this._subscribers[r]&&(this._subscribers[r]=this._subscribers[r].filter(f,r))}.bind(this)),r}waitForEvent(r){return new Promise(function(t,e){this.subscribe({type:r,callback:t,once:!0,error:e})}.bind(this))}chain(r,...t){return function(e){return this[r](...t)}.bind(this)}static Event=class{constructor(r,t){this.type=r;for(let r in t)this[r]=t[r]}}}
export class Album extends EventTarget{static players={};constructor(t={}){super(!!t),this.title=t.title,this.tracks=[],t.tracks&&this.push(...t.tracks)}push(...t){return t.forEach(function(t){if(Album.prototype.isPrototypeOf(t))return this.push(...t.tracks);if(!Album.players[t.filetype])return console.warn("Unsupported Track filetype: "+t.filetype,t);let r=0===this.length?0:Math.max(...this.getInfo("track_num"))+1,e=t.clone?t.clone():new Album.players[t.filetype].Track(t);e.track_num=r,this.tracks.push(e)}.bind(this)),this.publish(new this.constructor.Event("add"))}insert(t,...r){return r.forEach(function(r){if(Album.prototype.isPrototypeOf(r))return this.insert(t,...r.tracks);if(!Album.players[r.filetype])return console.warn("Unsupported Track filetype: "+r.filetype,r);if(t>=this.length)return this.push(r),t++;let e=0===this.length?0:this.tracks[(s=t,n=this.length,(s%n+n)%n)].track_num;var s,n;this.tracks.forEach((function(t,r,s){t.track_num>=e&&s[r].track_num++}));let i=r.clone?r.clone():new Album.players[r.filetype].Track(r);i.track_num=e,this.tracks.splice(t,0,i),t++}.bind(this)),this.publish(new this.constructor.Event("add"))}remove(...t){return t.forEach(function(t){if(Album.prototype.isPrototypeOf(t))return this.remove(...t.tracks);this.tracks=this.tracks.filter((function(r){return!r.equals(t)}))}.bind(this)),this.publish(new this.constructor.Event("remove"))}clear(){this.tracks.length=0,this.publish(new this.constructor.Event("clear"))}shuffle(){for(let t=this.length-1;t>0;t--){const r=Math.floor(Math.random()*(t+1));[this.tracks[t],this.tracks[r]]=[this.tracks[r],this.tracks[t]]}return this.publish(new this.constructor.Event("shuffle"))}sort(t="track_num",r=!1){return this.tracks.sort((function(r,e){let s=r.compare(e,t);return 0===s&&(s=r.compare(e,"title")),0===s&&(s=r.compare(e,"src")),s})),r&&this.tracks.reverse(),this.publish(new this.constructor.Event("sort"))}filter(t){return this.clone().tracks.filter((function(r,e,s){return t(r,e,s)}))}findIndex(t){return this.tracks.findIndex((function(r){return r.equals(t)}))}find(t){return this.tracks.find((function(r){return r.equals(t)}))}has(t){return this.tracks.some((function(r){if(r.equals(t))return!0}))}getInfo(t){let r=[];return this.tracks.forEach(function(e){void 0!==e[t]&&r.push(e[t])}.bind(this)),r}get length(){return this.tracks.length}toJSON(t){let r={};r.title=this.title;let e=[...this.tracks];return e.sort((function(t,r){let e=t.compare(r,"track_num");return 0===e&&(e=t.compare(r,"title")),0===e&&(e=t.compare(r,"src")),e})),r.tracks=e.map((function(t){return t.toJSON()})),r}static fromJSON(t){return new Album(JSON.parse(t))}clone(){return this.constructor.fromJSON(JSON.stringify(this))}equals(t){return JSON.stringify(this)===JSON.stringify(t)}toString(){return JSON.stringify(this)}static isValidTrack(t){return Object.values(Album.players).some((function(r){return r.isValidTrack(t)}))}}
export class Queue extends Album{constructor(t={}){Album.players=Queue.players,super(t),this.current_track=void 0}next(t=1){let r=this.findIndex(this.current_track);if(-1===r)throw new Error("Failed to find current track!");r+t>=this.length&&this.publish(new this.constructor.Event("done"));var e,s;return e=r+t,s=this.length,r=(e%s+s)%s,this.current_track=this.tracks[r],this.publish(new this.constructor.Event("next"))}previous(t=1){return this.next(-t)}insertNext(...t){let r=this.findIndex(this.current_track)+1;return this.insert(r,...t)}shuffle(){let t=this.findIndex(this.current_track);if(-1===t)return super.shuffle();let r=new Queue({tracks:this.tracks.slice(0,t)}),e=this.current_track.clone(),s=new Queue({tracks:this.tracks.slice(t+1)});r.shuffle(),s.shuffle();let n=[...this.tracks];return this.clear(),this.push(r,e,s),n.forEach(function(t){this.find(t).track_num=t.track_num}.bind(this)),this.publish(new this.constructor.Event("shuffle"))}toJSON(t){let r={};r.title=this.title;let e=[...this.tracks];return r.tracks=e.map((function(t){return t.toJSON()})),r}async publish(t){return this.current_track&&(t.current_track=this.current_track.clone()),super.publish(t)}static fromJSON(t){return new Queue(JSON.parse(t))}}
export class Player extends EventTarget{static Track=class extends Track{constructor(t){super(t),this.filetype="DEFAULT"}static fromJSON(t){return new Player.Track(JSON.parse(t))}};constructor(t=!0){super(t),this._player={src:"",time:0,duration:0,volume:1,paused:!0,muted:!1},this._command_queue=[]}async destroy(){let t=await this.publish(new this.constructor.Event("destroy"));return this._ready=!1,Object.values(this._subscribers).forEach((function(t){t.length=0})),t}async load(t){let e=this.waitForEvent("loaded");try{await fetch(t.src),this._player.src=t.src,this.publish(new this.constructor.Event("loaded"))}catch(t){this.publish(new this.constructor.Event("error"))}return e}async play(){return this._player.paused=!1,this.publish(new this.constructor.Event("play"))}async pause(){return this._player.paused=!0,this.publish(new this.constructor.Event("pause"))}async seek(t){let e=await this.getStatus();this._player.time=t;let s=this.publish(new this.constructor.Event("timeupdate"));return t>=e.duration&&this.publish(new this.constructor.Event("ended")),s}async fastForward(t){let e=await this.getStatus();return this.seek(e.time+t)}async setVolume(t){return this._player.volume=t,this.publish(new this.constructor.Event("volumechange"))}async setMuted(t){return this._player.muted=1==t,this.publish(new this.constructor.Event("volumechange"))}async stop(){return await this.pause(),await this.seek(0),this.publish(new this.constructor.Event("stop"))}async getStatus(){return this._player}async publish(t){return t.status=await this.getStatus(),super.publish(t)}static isValidTrack(t){let e=this.Track.prototype.isPrototypeOf(t),s=this.name===t.filetype;return e&&s}async enqueue(t,...e){return new Promise(function(s,r){let i={f:"function"==typeof t?t:this[t].bind(this),res:s,rej:r,args:e};this._command_queue.push(i),1===this._command_queue.length&&this.dequeue()}.bind(this))}async dequeue(){if(0===this._command_queue.length)return;let t=this._command_queue[0];try{let e=await t.f(...t.args);t.res(e)}catch(e){t.rej(e)}finally{return this._command_queue.shift(),this.dequeue()}}async clear(){0!==this._command_queue.length&&(this._command_queue.length=1,await this.enqueue((function(){})))}static supported_features={}}
export class MetaMusic extends Player{static players={};static Track=class extends Player.Track{constructor(t){if(MetaMusic.players[t.filetype])return new MetaMusic.players[t.filetype].Track(t);super(t)}static fromJSON(t){let e=JSON.parse(t);return MetaMusic.players[e.filetype]?new MetaMusic.players[e.filetype].Track(e):new Player.Track(JSON.parse(t))}};constructor(){Queue.players=MetaMusic.players,super(!1),delete this._player,this.queue=new Queue,this.queue.subscribe({type:"all",callback:function(t){this.publish(t)}.bind(this)}),this.current_player=new Player,this._players={},Object.values(this.constructor.players).forEach(function(t){this._players[t.name]=new t,this._players[t.name].subscribe({type:"error",callback:function(e){this.current_player===this._players[t.name]&&this.publish(e)}.bind(this)}),this._players[t.name].subscribe({type:"timeupdate",callback:function(e){this.current_player===this._players[t.name]&&this.publish(e)}.bind(this)}),this._players[t.name].subscribe({type:"ended",callback:function(e){this.current_player===this._players[t.name]&&this.publish(e),this.queue.has(this.current_track)&&this.next(1)}.bind(this)})}.bind(this)),this.waitForAll("waitForEvent","ready").then(function(){this.ready=!0}.bind(this))}get current_track(){return this.queue.current_track}set current_track(t){this.queue.current_track=t}async next(t=1){let e=this.queue.findIndex(this.current_track),r=await this.getStatus();return this.queue.next(t),await this.stop(),await this.load(this.current_track),!r.paused&&e+t<this.queue.length&&await this.play(),this.current_track}async previous(t=1){return this.next(-t)}async destroy(){let t=super.destroy();return await this.waitForAll("destroy"),t}async load(t){if(!this.constructor.isValidTrack(t))throw new Error("Invalid Filetype");let e=await this.getStatus();await this.stop(),this.current_track=t,this.current_player=this._players[t.filetype];let r=await this.current_player.load(t);return await this.setVolume(e.volume),this.publish(r)}async play(){return this.publish(await this.current_player.play())}async pause(){return this.publish(await this.current_player.pause())}async seek(t){return this.publish(await this.current_player.seek(t))}async fastForward(t){return this.publish(await this.current_player.fastForward(t))}async setVolume(t){return this.publish(await this.current_player.setVolume(t))}async setMuted(t){return this.publish(await this.current_player.setMuted(t))}async stop(){return this.publish(await this.current_player.stop())}all(t,...e){return Object.values(this._players).map((function(r){try{return r[t](...e)}catch(t){return Promise.reject(t)}}))}async waitForAll(t,...e){return Promise.allSettled(this.all(t,...e))}async getStatus(){return this.current_player.getStatus()}async getPlayerStatus(){return Promise.all(this.all("getStatus"))}static isValidTrack(t){return Object.values(MetaMusic.players).some((function(e){return e.isValidTrack(t)}))}}